Notes March 2010
~~~~~~~~~~~~~~~~

* I would love to simplify the Graph type, further, but I don't know
  how.

* Talking to John, we agreed that a common use of Hoopl will be to
  analyse full graphs, to get a full mapping (BlockId -> fact), for
  the *internal* nodes of the graph, not just its out-edges.  Inded
  for a full graph (eg a procedure body) there wil *be* no out-edges.

  So maybe we want 
     data Graph n e x where
       ...
       GMany { 
 	g_entry :: Block n e C,
	g_blocks :: FullGraph n,
        ...}

  where
    newtype FullGraph n = FG [Block n C C]
  
  And the client might define a procedure thus:

    data Procedure = Proc BlockId  -- Entry point
                          (FullGraph CmmNode)

  Now we may imagine
	GFT_FullGraph n f = GFT (FullGraph n)
  and the client interface might be exposed for FullGraph.
  Meanwhile, the recursive invocations of the analysis still
  work on Graphs.

  So a FullGraph would be a fourth kind of entity (as well as
  nodes, blocks, graphs), albeit one that is not an instance of
  Edges.

* Incidentally, eleveating FullGraph in this way would let
  us switch to BlockEnv or whatever else we wanted if that 
  proved convenient.

* I was thinking how to do dead-block elimination.  Given a fact
  (B17 -> Dead), how can I rewrite the block with label B17 to
  an empty graph?  I'd like to write
      rewrite fact_fun (Label b) 
        | fact_fun b == Dead = Just (GUnit (BUnit b `BCat` unreachable))
        | otherwise          = Nothing

  So what is "unreachable :: Block".  I suppose it's a new constructor
  of the Block type, that eats all its downstream fellows:

	data Block n e x where
          BUnr :: Block n O x
	  ...as before...

  It's a bit like the GNil constructor, which is there primarily
  to allow us to rewrite a node to a no-op.

  Its a bit tiresome that it has be be in Block not Graph, but
  we still need that Label. 


Ideas
~~~~~
"Optimization" encompasses:
  - substitution informed by equational reasoning (about states)
  - removal of redundant code, as justified by reasoning about
    continuations

"Code motion" is achieved by inserting redundant code,
thereby making original code redundant, which in turn
can be removed.

Technique
~~~~~~~~~
No single technique; the secret sauce is how we combine things:
  - Zipper CFG
  - Disctinct representations for construction and analyis of CFGs
  - Maximum use of polymorphism
  - Type classes to make notation resemble prior art
  - Transfer equations coded in dragon-book style
  - Fixed points courtesy Lerner, Grove, and Chambers (2002)

Contribution
~~~~~~~~~~~~
We make dataflow optimization easy to think about and easy to build:

 * Ideas that reconcile the ad-hoc 'optimization zoo' found in the
   dragon book with methods of reasoning long understood by functional
   programmers.

 * Design and implementation that make it not just possible but *easy*
   to use dataflow techniques in your compiler.



---------------------------------
Working title: Dataflow Optimization Made Simple

Note: By decomposing 'optimizations' into smaller units, we simplify.
'induction-variable elimination' is *not* an atomic thing!


---------------------------------
Vague Outline
1. Intro
2. Short example
3. Logical view of optimization
4. Clients (examples, including type class declarations)
5. Graphs
6. Fixed-point computation; the dataflow monad
7. Discussion

